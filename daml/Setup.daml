module Setup where

import DA.Foldable (forA_)
import DA.Optional (fromSomeNote)
import qualified DA.Text as T
import qualified DA.List as List
import Daml.Script
import qualified User as U
import Hawala

-- | A test user for the create-daml-app network.
data TestUser = TestUser with
  alias : Text
  public : Party

-- | Create a public party, then create three test users.
setup : Script ()
setup = do
  public <- createPublic

  let aliases = ["Alice", "Bob", "Charlie", "Henry", "Hannah", "Hector", "Heidi"]
  users <- mapA (\alias -> createTestUser $ TestUser alias public) aliases

  forA_ (zip users aliases) $ \(user, alias) -> submit user do
    createCmd U.Alias with username = user; alias ; public

  let fees: [Decimal]Â = [0.0, 0.0, 0.0, 0.03, 0.05, 0.035, 0.01]
  forA_ (zip users fees) $ \(user, fee) -> submit user do
    createCmd HawalaAccount with owner = user; fee; observers = users

  let alice = List.head users
  let bob = users List.!! 1

--  submit alice do
--    createCmd LockedIou with
--      iou = Iou with issuer = alice; owner = users List.!! 3; amount = 123.45
--      hash = T.sha256 "Abracadabra"

  submit alice do
    createCmd TransferProposal with
      origin = alice
      source = alice
      destination = bob
      intermediary = users List.!! 3
      amount = 100.0
      hash = T.sha256 "Abracadabra"
      link = None

  return ()
  --forA_ aliases $ \alias -> createTestUser $ TestUser alias public

-- | Create a test user.
createTestUser : TestUser -> Script Party
createTestUser TestUser{alias, public} = do
  u <- getOrCreateUser alias (Some public)
  let p = getPrimaryParty u
  pure p

-- | Create the public party.
createPublic : Script Party
createPublic = do
  publicUser <- getOrCreateUser "Public" None
  pure $ getPrimaryParty publicUser


-- | Get a user by their id. If the user doesn't exist, it is created.
getOrCreateUser : Text -> Optional Party -> Script User
getOrCreateUser alias publicM = do
  userId <- validateUserId $ toUserId alias
  try
    getUser userId
  catch
    UserNotFound _ -> do
      p <- allocateParty alias
      let u = User userId (Some p)
      createUser u $ CanActAs p :: [CanReadAs public | Some public <- [publicM]]
      pure u

-- | Convert a text to a valid user id.
toUserId : Text -> Text
toUserId = T.asciiToLower

-- | Try to get the primary party of a user and fail if the user has no associated primary party.
getPrimaryParty : User -> Party
getPrimaryParty u = fromSomeNote ("User " <> userIdToText u.userId <> " is missing a primary party.") u.primaryParty
